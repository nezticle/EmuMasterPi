/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include "cheats.h"
#include "mem.h"
#include <base/configuration.h>

static const u8 v1_deadtable1[256] = {
	0x31, 0x1c, 0x23, 0xe5, 0x89, 0x8e, 0xa1, 0x37, 0x74, 0x6d, 0x67, 0xfc, 0x1f, 0xc0, 0xb1, 0x94,
	0x3b, 0x05, 0x56, 0x86, 0x00, 0x24, 0xf0, 0x17, 0x72, 0xa2, 0x3d, 0x1b, 0xe3, 0x17, 0xc5, 0x0b,
	0xb9, 0xe2, 0xbd, 0x58, 0x71, 0x1b, 0x2c, 0xff, 0xe4, 0xc9, 0x4c, 0x5e, 0xc9, 0x55, 0x33, 0x45,
	0x7c, 0x3f, 0xb2, 0x51, 0xfe, 0x10, 0x7e, 0x75, 0x3c, 0x90, 0x8d, 0xda, 0x94, 0x38, 0xc3, 0xe9,
	0x95, 0xea, 0xce, 0xa6, 0x06, 0xe0, 0x4f, 0x3f, 0x2a, 0xe3, 0x3a, 0xe4, 0x43, 0xbd, 0x7f, 0xda,
	0x55, 0xf0, 0xea, 0xcb, 0x2c, 0xa8, 0x47, 0x61, 0xa0, 0xef, 0xcb, 0x13, 0x18, 0x20, 0xaf, 0x3e,
	0x4d, 0x9e, 0x1e, 0x77, 0x51, 0xc5, 0x51, 0x20, 0xcf, 0x21, 0xf9, 0x39, 0x94, 0xde, 0xdd, 0x79,
	0x4e, 0x80, 0xc4, 0x9d, 0x94, 0xd5, 0x95, 0x01, 0x27, 0x27, 0xbd, 0x6d, 0x78, 0xb5, 0xd1, 0x31,
	0x6a, 0x65, 0x74, 0x74, 0x58, 0xb3, 0x7c, 0xc9, 0x5a, 0xed, 0x50, 0x03, 0xc4, 0xa2, 0x94, 0x4b,
	0xf0, 0x58, 0x09, 0x6f, 0x3e, 0x7d, 0xae, 0x7d, 0x58, 0xa0, 0x2c, 0x91, 0xbb, 0xe1, 0x70, 0xeb,
	0x73, 0xa6, 0x9a, 0x44, 0x25, 0x90, 0x16, 0x62, 0x53, 0xae, 0x08, 0xeb, 0xdc, 0xf0, 0xee, 0x77,
	0xc2, 0xde, 0x81, 0xe8, 0x30, 0x89, 0xdb, 0xfe, 0xbc, 0xc2, 0xdf, 0x26, 0xe9, 0x8b, 0xd6, 0x93,
	0xf0, 0xcb, 0x56, 0x90, 0xc0, 0x46, 0x68, 0x15, 0x43, 0xcb, 0xe9, 0x98, 0xe3, 0xaf, 0x31, 0x25,
	0x4d, 0x7b, 0xf3, 0xb1, 0x74, 0xe2, 0x64, 0xac, 0xd9, 0xf6, 0xa0, 0xd5, 0x0b, 0x9b, 0x49, 0x52,
	0x69, 0x3b, 0x71, 0x00, 0x2f, 0xbb, 0xba, 0x08, 0xb1, 0xae, 0xbb, 0xb3, 0xe1, 0xc9, 0xa6, 0x7f,
	0x17, 0x97, 0x28, 0x72, 0x12, 0x6e, 0x91, 0xae, 0x3a, 0xa2, 0x35, 0x46, 0x27, 0xf8, 0x12, 0x50
};

static const u8 v1_deadtable2[256] = {
	0xd8, 0x65, 0x04, 0xc2, 0x65, 0xd5, 0xb0, 0x0c, 0xdf, 0x9d, 0xf0, 0xc3, 0x9a, 0x17, 0xc9, 0xa6,
	0xe1, 0xac, 0x0d, 0x14, 0x2f, 0x3c, 0x2c, 0x87, 0xa2, 0xbf, 0x4d, 0x5f, 0xac, 0x2d, 0x9d, 0xe1,
	0x0c, 0x9c, 0xe7, 0x7f, 0xfc, 0xa8, 0x66, 0x59, 0xac, 0x18, 0xd7, 0x05, 0xf0, 0xbf, 0xd1, 0x8b,
	0x35, 0x9f, 0x59, 0xb4, 0xba, 0x55, 0xb2, 0x85, 0xfd, 0xb1, 0x72, 0x06, 0x73, 0xa4, 0xdb, 0x48,
	0x7b, 0x5f, 0x67, 0xa5, 0x95, 0xb9, 0xa5, 0x4a, 0xcf, 0xd1, 0x44, 0xf3, 0x81, 0xf5, 0x6d, 0xf6,
	0x3a, 0xc3, 0x57, 0x83, 0xfa, 0x8e, 0x15, 0x2a, 0xa2, 0x04, 0xb2, 0x9d, 0xa8, 0x0d, 0x7f, 0xb8,
	0x0f, 0xf6, 0xac, 0xbe, 0x97, 0xce, 0x16, 0xe6, 0x31, 0x10, 0x60, 0x16, 0xb5, 0x83, 0x45, 0xee,
	0xd7, 0x5f, 0x2c, 0x08, 0x58, 0xb1, 0xfd, 0x7e, 0x79, 0x00, 0x34, 0xad, 0xb5, 0x31, 0x34, 0x39,
	0xaf, 0xa8, 0xdd, 0x52, 0x6a, 0xb0, 0x60, 0x35, 0xb8, 0x1d, 0x52, 0xf5, 0xf5, 0x30, 0x00, 0x7b,
	0xf4, 0xba, 0x03, 0xcb, 0x3a, 0x84, 0x14, 0x8a, 0x6a, 0xef, 0x21, 0xbd, 0x01, 0xd8, 0xa0, 0xd4,
	0x43, 0xbe, 0x23, 0xe7, 0x76, 0x27, 0x2c, 0x3f, 0x4d, 0x3f, 0x43, 0x18, 0xa7, 0xc3, 0x47, 0xa5,
	0x7a, 0x1d, 0x02, 0x55, 0x09, 0xd1, 0xff, 0x55, 0x5e, 0x17, 0xa0, 0x56, 0xf4, 0xc9, 0x6b, 0x90,
	0xb4, 0x80, 0xa5, 0x07, 0x22, 0xfb, 0x22, 0x0d, 0xd9, 0xc0, 0x5b, 0x08, 0x35, 0x05, 0xc1, 0x75,
	0x4f, 0xd0, 0x51, 0x2d, 0x2e, 0x5e, 0x69, 0xe7, 0x3b, 0xc2, 0xda, 0xff, 0xf6, 0xce, 0x3e, 0x76,
	0xe8, 0x36, 0x8c, 0x39, 0xd8, 0xf3, 0xe9, 0xa6, 0x42, 0xe6, 0xc1, 0x4c, 0x05, 0xbe, 0x17, 0xf2,
	0x5c, 0x1b, 0x19, 0xdb, 0x0f, 0xf3, 0xf8, 0x49, 0xeb, 0x36, 0xf6, 0x40, 0x6f, 0xad, 0xc1, 0x8c
};

static const u8 v3_deadtable1[256] = {
	0xd0, 0xff, 0xba, 0xe5, 0xc1, 0xc7, 0xdb, 0x5b, 0x16, 0xe3, 0x6e, 0x26, 0x62, 0x31, 0x2e, 0x2a,
	0xd1, 0xbb, 0x4a, 0xe6, 0xae, 0x2f, 0x0a, 0x90, 0x29, 0x90, 0xb6, 0x67, 0x58, 0x2a, 0xb4, 0x45,
	0x7b, 0xcb, 0xf0, 0x73, 0x84, 0x30, 0x81, 0xc2, 0xd7, 0xbe, 0x89, 0xd7, 0x4e, 0x73, 0x5c, 0xc7,
	0x80, 0x1b, 0xe5, 0xe4, 0x43, 0xc7, 0x46, 0xd6, 0x6f, 0x7b, 0xbf, 0xed, 0xe5, 0x27, 0xd1, 0xb5,
	0xd0, 0xd8, 0xa3, 0xcb, 0x2b, 0x30, 0xa4, 0xf0, 0x84, 0x14, 0x72, 0x5c, 0xff, 0xa4, 0xfb, 0x54,
	0x9d, 0x70, 0xe2, 0xff, 0xbe, 0xe8, 0x24, 0x76, 0xe5, 0x15, 0xfb, 0x1a, 0xbc, 0x87, 0x02, 0x2a,
	0x58, 0x8f, 0x9a, 0x95, 0xbd, 0xae, 0x8d, 0x0c, 0xa5, 0x4c, 0xf2, 0x5c, 0x7d, 0xad, 0x51, 0xfb,
	0xb1, 0x22, 0x07, 0xe0, 0x29, 0x7c, 0xeb, 0x98, 0x14, 0xc6, 0x31, 0x97, 0xe4, 0x34, 0x8f, 0xcc,
	0x99, 0x56, 0x9f, 0x78, 0x43, 0x91, 0x85, 0x3f, 0xc2, 0xd0, 0xd1, 0x80, 0xd1, 0x77, 0xa7, 0xe2,
	0x43, 0x99, 0x1d, 0x2f, 0x8b, 0x6a, 0xe4, 0x66, 0x82, 0xf7, 0x2b, 0x0b, 0x65, 0x14, 0xc0, 0xc2,
	0x1d, 0x96, 0x78, 0x1c, 0xc4, 0xc3, 0xd2, 0xb1, 0x64, 0x07, 0xd7, 0x6f, 0x02, 0xe9, 0x44, 0x31,
	0xdb, 0x3c, 0xeb, 0x93, 0xed, 0x9a, 0x57, 0x05, 0xb9, 0x0e, 0xaf, 0x1f, 0x48, 0x11, 0xdc, 0x35,
	0x6c, 0xb8, 0xee, 0x2a, 0x48, 0x2b, 0xbc, 0x89, 0x12, 0x59, 0xcb, 0xd1, 0x18, 0xea, 0x72, 0x11,
	0x01, 0x75, 0x3b, 0xb5, 0x56, 0xf4, 0x8b, 0xa0, 0x41, 0x75, 0x86, 0x7b, 0x94, 0x12, 0x2d, 0x4c,
	0x0c, 0x22, 0xc9, 0x4a, 0xd8, 0xb1, 0x8d, 0xf0, 0x55, 0x2e, 0x77, 0x50, 0x1c, 0x64, 0x77, 0xaa,
	0x3e, 0xac, 0xd3, 0x3d, 0xce, 0x60, 0xca, 0x5d, 0xa0, 0x92, 0x78, 0xc6, 0x51, 0xfe, 0xf9, 0x30
};

static const u8 v3_deadtable2[256] = {
	0xaa, 0xaf, 0xf0, 0x72, 0x90, 0xf7, 0x71, 0x27, 0x06, 0x11, 0xeb, 0x9c, 0x37, 0x12, 0x72, 0xaa,
	0x65, 0xbc, 0x0d, 0x4a, 0x76, 0xf6, 0x5c, 0xaa, 0xb0, 0x7a, 0x7d, 0x81, 0xc1, 0xce, 0x2f, 0x9f,
	0x02, 0x75, 0x38, 0xc8, 0xfc, 0x66, 0x05, 0xc2, 0x2c, 0xbd, 0x91, 0xad, 0x03, 0xb1, 0x88, 0x93,
	0x31, 0xc6, 0xab, 0x40, 0x23, 0x43, 0x76, 0x54, 0xca, 0xe7, 0x00, 0x96, 0x9f, 0xd8, 0x24, 0x8b,
	0xe4, 0xdc, 0xde, 0x48, 0x2c, 0xcb, 0xf7, 0x84, 0x1d, 0x45, 0xe5, 0xf1, 0x75, 0xa0, 0xed, 0xcd,
	0x4b, 0x24, 0x8a, 0xb3, 0x98, 0x7b, 0x12, 0xb8, 0xf5, 0x63, 0x97, 0xb3, 0xa6, 0xa6, 0x0b, 0xdc,
	0xd8, 0x4c, 0xa8, 0x99, 0x27, 0x0f, 0x8f, 0x94, 0x63, 0x0f, 0xb0, 0x11, 0x94, 0xc7, 0xe9, 0x7f,
	0x3b, 0x40, 0x72, 0x4c, 0xdb, 0x84, 0x78, 0xfe, 0xb8, 0x56, 0x08, 0x80, 0xdf, 0x20, 0x2f, 0xb9,
	0x66, 0x2d, 0x60, 0x63, 0xf5, 0x18, 0x15, 0x1b, 0x86, 0x85, 0xb9, 0xb4, 0x68, 0x0e, 0xc6, 0xd1,
	0x8a, 0x81, 0x2b, 0xb3, 0xf6, 0x48, 0xf0, 0x4f, 0x9c, 0x28, 0x1c, 0xa4, 0x51, 0x2f, 0xd7, 0x4b,
	0x17, 0xe7, 0xcc, 0x50, 0x9f, 0xd0, 0xd1, 0x40, 0x0c, 0x0d, 0xca, 0x83, 0xfa, 0x5e, 0xca, 0xec,
	0xbf, 0x4e, 0x7c, 0x8f, 0xf0, 0xae, 0xc2, 0xd3, 0x28, 0x41, 0x9b, 0xc8, 0x04, 0xb9, 0x4a, 0xba,
	0x72, 0xe2, 0xb5, 0x06, 0x2c, 0x1e, 0x0b, 0x2c, 0x7f, 0x11, 0xa9, 0x26, 0x51, 0x9d, 0x3f, 0xf8,
	0x62, 0x11, 0x2e, 0x89, 0xd2, 0x9d, 0x35, 0xb1, 0xe4, 0x0a, 0x4d, 0x93, 0x01, 0xa7, 0xd1, 0x2d,
	0x00, 0x87, 0xe2, 0x2d, 0xa4, 0xe9, 0x0a, 0x06, 0x66, 0xf8, 0x1f, 0x44, 0x75, 0xb5, 0x6b, 0x1c,
	0xfc, 0x31, 0x09, 0x48, 0xa3, 0xff, 0x92, 0x12, 0x58, 0xe9, 0xfa, 0xae, 0x4f, 0xe2, 0xb4, 0xcc
};

GbaGameSharkCheat::GbaGameSharkCheat(const GbaGameSharkCheatGroup &group,
									 const QString &cheat) :
	m_addr(0),
	m_data(0)
{
	QString uCheat = cheat.toUpper();
	// GameShark codes must be 16 char length
	if (uCheat.size() != 16)
		return;
	// check if each digit is hex
	for (int i = 0; i < 16; i++) {
		if ((uCheat.at(i) < '0' || uCheat.at(i) > '9') &&
			(uCheat.at(i) < 'A' || uCheat.at(i) > 'F')) {
			return;
		}
	}

	m_addr = uCheat.left(8).toInt(0, 16);
	m_data = uCheat.right(8).toInt(0, 16);

	// decrypt the code
	u32 rollingSeed = 0xc6ef3720;
	int bitsLeft = 32;
	while (bitsLeft > 0) {
		m_data -= ((((m_addr << 4) + group.seed(2)) ^
					(m_addr + rollingSeed)) ^
				   ((m_addr >> 5) + group.seed(3)));
		m_addr -= ((((m_data << 4) + group.seed(0)) ^
					(m_data + rollingSeed)) ^
				   ((m_data >> 5) + group.seed(1)));
		rollingSeed -= 0x9e3779b9;
		bitsLeft--;
	}
}

// TODO check idcode
/*!
	If data value of the cheat is equal to 0x001DC0DE it means it contains
	the ID of the game it is meant to be used. The functions returns this
	code if the cheat contains ID, otherwise returns empty string.
 */
QString GbaGameSharkCheat::idcode() const
{
	if (m_data == 0x001dc0de) {
		char buf[5];
		*(u32*)buf = m_addr;
		buf[4] = 0;
		return buf;
	}
	return QString();
}

GbaGameSharkCheatGroup::GbaGameSharkCheatGroup(Generation gen,
											   const QStringList &list) :
	m_generation(gen),
	m_cheatStrings(list),
	m_enabled(false)
{
	changeEncryption(0);

	for (int i = 0; i < list.size(); i++) {
		GbaGameSharkCheat cheat(*this, list.at(i));
		if (cheat.addr() == 0xdeadface)
			changeEncryption(cheat.data());
		m_cheats.append(cheat);
	}
}

QString GbaGameSharkCheatGroup::idcode() const
{
	for (int i = 0; i < m_cheats.size(); i++) {
		if (!m_cheats.at(i).idcode().isEmpty())
			return m_cheats.at(i).idcode();
	}
	return QString();
}

void GbaGameSharkCheatGroup::process() const
{
	if (m_enabled) {
		if (m_generation == V1)
			processV1();
		else
			processV3();
	}
}

void GbaGameSharkCheatGroup::setEnabled(bool on)
{
	m_enabled = on;
}

static u32 genSeed(u8 upper, u8 seed, const u8 *deadtable1, const u8 *deadtable2)
{
	u32 newSeed = 0;
	for (int i = 0; i < 4; i++) {
		newSeed = ((newSeed << 8) |
				   ((deadtable1[(i + upper) & 0xff] + deadtable2[seed]) & 0xFF));
	}
	return newSeed;
}

void GbaGameSharkCheatGroup::changeEncryption(u16 data)
{
	m_deadface = data;
	const u8 *deadtable1 = ((m_generation == V3) ? v3_deadtable1 : v1_deadtable1);
	const u8 *deadtable2 = ((m_generation == V3) ? v3_deadtable2 : v1_deadtable2);
	for (int i = 0; i < 4; i++) {
		m_seed[i] = genSeed(((data & 0xff00) >> 8),
							(data & 0xff) + i, deadtable1, deadtable2);
	}
}

void GbaGameSharkCheatGroup::processV1() const
{
	int i = 0;
	while (i < m_cheats.size()) {
		u32 addr = m_cheats.at(i).addr();
		u32 data = m_cheats.at(i).data();
		i++;

		u32 opcode = addr >> 28;
		addr &= 0x0fffffff;

		switch (opcode) {
		case 0x0:
			write_memory8(addr, data);
			break;

		case 0x1:
			write_memory16(addr, data);
			break;

		case 0x2:
			write_memory32(addr, data);
			break;

		case 0x3: {
			int numAddresses = addr & 0xffff;
			for (int i2 = 0; i2 < numAddresses && i < m_cheats.size(); i2++) {
				u32 addr1 = m_cheats.at(i).addr();
				u32 addr2 = m_cheats.at(i).data();
				i++;

				write_memory32(addr1, data);
				if (addr2 != 0)
					write_memory32(addr2, data);
			}
			break;
		}

			// ROM patch not supported yet
		case 0x6:
			break;

			// GS button down not supported yet
		case 0x8:
			break;

			// Reencryption (DEADFACE) not supported yet
		case 0xd:
			break;

		case 0xe:
			if (read_memory16(data & 0x0fffffff) != (addr & 0xffff)) {
				u32 skip = ((addr >> 16) & 0x03);
				i += skip;
			}
			break;

			// Hook routine not supported yet (not important??)
		case 0xf:
			break;
		}
	}
}

void GbaGameSharkCheatGroup::processV3() const
{
	int i = 0;
	while (i < m_cheats.size()) {
		u32 addr = m_cheats.at(i).addr();
		u32 data = m_cheats.at(i).data();
		i++;

		int opcode = addr >> 28;
		addr &= 0x0fffffff;

		switch (opcode) {
		case 0x0:
			opcode = addr >> 24;
			addr = (addr & 0xfffff) + ((addr << 4) & 0xf000000);

			switch (opcode) {
			case 0x0: {
				int iterations = data >> 24;
				data &= 0xff;
				for (int i2 = 0; i2 <= iterations; i2++, addr++)
					write_memory8(addr, data);
				break;
			}

			case 0x2: {
				int iterations = data >> 16;
				data &= 0xffff;
				for (int i2 = 0; i2 <= iterations; i2++, addr += 2)
					write_memory16(addr, data);
				break;
			}

			case 0x4:
				write_memory32(addr, data);
				break;
			}
			break;

		case 0x4:
			opcode = addr >> 24;
			addr = (addr & 0xfffff) + ((addr << 4) & 0xf000000);

			switch (opcode) {
			case 0x0:
				addr = read_memory32(addr) + (data >> 24);
				write_memory8(addr, data & 0xff);
				break;

			case 0x2:
				addr = read_memory32(addr) + ((data >> 16) * 2);
				write_memory16(addr, data & 0xffff);
				break;

			case 0x4:
				addr = read_memory32(addr);
				write_memory32(addr, data);
				break;
			}
			break;

		case 0x8:
			opcode = addr >> 24;
			addr = (addr & 0xfffff) + ((addr << 4) & 0xf000000);

			switch (opcode) {
			case 0x0:
				data = (data & 0xff) + read_memory8(addr);
				write_memory8(addr, data);
				break;

			case 0x2:
				data = (data & 0xffff) + read_memory16(addr);
				write_memory16(addr, data);
				break;

			case 0x4:
				data = data + read_memory32(addr);
				write_memory32(addr, data);
				break;
			}
			break;

		case 0xc:
			opcode = addr >> 24;
			addr = (addr & 0xffffff) + 0x4000000;

			switch(opcode) {
			case 0x6:
				write_memory16(addr, data);
				break;

			case 0x7:
				write_memory32(addr, data);
				break;
			}
			break;
		}
	}
}

void GbaGameSharkValidator::fixup(QString &input) const
{
	input = input.toUpper();
	QString result;
	for (int i = 0; i < input.size(); i++) {
		char c = input.at(i).toLatin1();
		if ((input.at(i) >= '0' && input.at(i) <= '9') ||
			(input.at(i) >= 'A' && input.at(i) <= 'F')) {
			result.append(c);
		}
	}
	input = result;
}

QValidator::State GbaGameSharkValidator::validate(QString &input, int &pos) const
{
	Q_UNUSED(pos)
	fixup(input);
	bool ok = true;
	if (input.size() != 16)
		ok = false;
	if (ok) {
		// check if each digit is hex
		for (int i = 0; i < 16; i++) {
			if ((input.at(i) < '0' || input.at(i) > '9') &&
				(input.at(i) < 'A' || input.at(i) > 'F')) {
				ok = false;
				break;
			}
		}
	}
	return ok ? Acceptable : Intermediate;
}

static QList<GbaGameSharkCheatGroup> processedGroups;
GbaCheats gbaCheats;

GbaCheats::GbaCheats()
{
	QHash<int, QByteArray> roles;
	roles.insert(GroupRole, "codeList");
	roles.insert(DescriptionRole, "codeDescription");
	roles.insert(EnableRole, "codeEnabled");
	setRoleNames(roles);
}

int GbaCheats::rowCount(const QModelIndex &parent) const
{
	Q_UNUSED(parent)
	return m_groups.size();
}

QVariant GbaCheats::data(const QModelIndex &index, int role) const
{
	if (role == GroupRole)
		return m_groups.at(index.row());
	else if (role == DescriptionRole)
		return m_descriptions.at(index.row());
	else if (role == EnableRole)
		return m_enabled.at(index.row());
	return QVariant();
}

void GbaCheats::setEnabled(int i, bool on)
{
	processedGroups[i].setEnabled(on);
	m_enabled[i] = on;
}

void GbaCheats::addNew(const QStringList &codeList,
					   const QString &description,
					   bool v3)
{
	beginInsertRows(QModelIndex(), m_groups.size(), m_groups.size());
	m_groups.append(codeList);
	m_descriptions.append(description);
	GbaGameSharkCheatGroup::Generation gen = (v3 ? GbaGameSharkCheatGroup::V3 :
												   GbaGameSharkCheatGroup::V1);
	m_generations.append(gen);
	GbaGameSharkCheatGroup group(gen, codeList);
	processedGroups.append(group);
	m_enabled.append(group.isEnabled());
	endInsertRows();
}

void GbaCheats::removeAt(int i)
{
	beginRemoveRows(QModelIndex(), i, i);
	m_groups.removeAt(i);
	m_descriptions.removeAt(i);
	m_generations.removeAt(i);
	m_enabled.removeAt(i);
	processedGroups.removeAt(i);
	endRemoveRows();
}

bool GbaCheats::checkIdcodeForGroup(int groupIndex, const QString &expected) const
{
	QString idcode = processedGroups.at(groupIndex).idcode();
	if (idcode.isEmpty())
		return true;
	return idcode == expected;
}

void GbaCheats::sl()
{
	// a hack to omit cheats in old states
	// TODO convert in state converter
	if (!emsl.save && emConf.value("version").toString() < QString("0.3.0"))
		return;

	if (!emsl.save)
		beginResetModel();
	emsl.begin("cheats");
	emsl.var("groups", m_groups);
	emsl.var("descriptions", m_descriptions);
	emsl.var("generations", m_generations);
	emsl.var("enabled", m_enabled);
	emsl.end();

	if (!emsl.save) {
		reloadCheats();
		endResetModel();
	}
}

void GbaCheats::reloadCheats()
{
	processedGroups.clear();

	for (int i = 0; i < m_groups.size(); i++) {
		GbaGameSharkCheatGroup::Generation gen =
				static_cast<GbaGameSharkCheatGroup::Generation>(m_generations.at(i));
		GbaGameSharkCheatGroup group(gen, m_groups.at(i));
		group.setEnabled(m_enabled.at(i));
		processedGroups.append(group);
	}
}

void gbaCheatsProcess()
{
	QList<GbaGameSharkCheatGroup>::ConstIterator i = processedGroups.constBegin();
	for (; i != processedGroups.constEnd(); i++) {
		if (i->isEnabled())
			i->process();
	}
}
